<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>World of Babi</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas { display: block; }
    #coinCounter {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: gold;
      padding: 10px 20px;
      border-radius: 10px;
      font-family: Arial, sans-serif;
      font-size: 24px;
      border: 2px solid gold;
      z-index: 100;
    }
    #instructions {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px 15px;
      border-radius: 10px;
      font-family: Arial, sans-serif;
      font-size: 14px;
      border: 1px solid white;
      z-index: 100;
    }
  </style>
</head>
<body>
<div id="coinCounter">ðŸ’° Coins: 0/5</div>
<div id="instructions">WASD: Move | Mouse: Look | Q/E: Rotate Character | Click: Lock Pointer</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
  /* ===================== CORE ===================== */
  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x87ceeb, 30, 200);

  const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  document.body.appendChild(renderer.domElement);

  /* ===================== IMPROVED CLOUD CLUSTERS ===================== */
  function createRealisticCloud(x, y, z, scale = 1) {
    const cloudGroup = new THREE.Group();
    
    const cloudConfig = [
      { x: 0, y: 0, z: 0, radius: 4 * scale },
      { x: 3 * scale, y: 1 * scale, z: -2 * scale, radius: 3.5 * scale },
      { x: -3 * scale, y: 1 * scale, z: 2 * scale, radius: 3.2 * scale },
      { x: 5 * scale, y: -1 * scale, z: -1 * scale, radius: 2.8 * scale },
      { x: -4 * scale, y: -1.5 * scale, z: 1 * scale, radius: 3 * scale },
      { x: 1.5 * scale, y: 2 * scale, z: 0, radius: 2.5 * scale },
      { x: -1.5 * scale, y: 2 * scale, z: 1.5 * scale, radius: 2.2 * scale },
      { x: 2.5 * scale, y: 0.5 * scale, z: 3 * scale, radius: 2 * scale },
      { x: -2.5 * scale, y: 0.5 * scale, z: -3 * scale, radius: 2.3 * scale },
    ];
    
    cloudConfig.forEach((sphere, i) => {
      const cloudMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.9,
        roughness: 1.0,
        metalness: 0.0
      });
      
      const cloudPart = new THREE.Mesh(
        new THREE.SphereGeometry(sphere.radius, 16, 12),
        cloudMaterial
      );
      
      cloudPart.position.set(sphere.x, sphere.y, sphere.z);
      cloudGroup.add(cloudPart);
    });
    
    for (let i = 0; i < 5; i++) {
      const wispMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.6,
        roughness: 1.0
      });
      
      const wisp = new THREE.Mesh(
        new THREE.SphereGeometry(1.2 * scale, 10, 8),
        wispMaterial
      );
      
      wisp.position.set(
        (Math.random() - 0.5) * 8 * scale,
        (Math.random() - 0.5) * 4 * scale + 2 * scale,
        (Math.random() - 0.5) * 8 * scale
      );
      cloudGroup.add(wisp);
    }
    
    cloudGroup.position.set(x, y, z);
    cloudGroup.userData = { 
      speed: (Math.random() * 0.02 + 0.01) * (scale < 1 ? 1.5 : 1),
      scale: scale,
      originalY: y
    };
    
    return cloudGroup;
  }

  const cloudClusters = [];
  
  cloudClusters.push(createRealisticCloud(-80, 60, -40, 1.2));
  cloudClusters.push(createRealisticCloud(100, 70, -80, 1.5));
  cloudClusters.push(createRealisticCloud(-120, 65, 20, 1.0));
  cloudClusters.push(createRealisticCloud(60, 75, 60, 1.3));
  cloudClusters.push(createRealisticCloud(-40, 55, -120, 0.8));
  cloudClusters.push(createRealisticCloud(140, 60, -40, 0.9));
  cloudClusters.push(createRealisticCloud(-150, 58, 80, 0.7));
  cloudClusters.push(createRealisticCloud(80, 62, 120, 0.8));
  cloudClusters.push(createRealisticCloud(-180, 50, -180, 0.6));
  cloudClusters.push(createRealisticCloud(180, 52, 180, 0.5));
  cloudClusters.push(createRealisticCloud(200, 48, -60, 0.5));
  cloudClusters.push(createRealisticCloud(-200, 53, 100, 0.6));

  cloudClusters.forEach(cloud => {
    scene.add(cloud);
  });

  /* ===================== FIXED SUN ===================== */
  const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
  const sunMaterial = new THREE.MeshBasicMaterial({ 
    color: 0xFFD700,
    transparent: true
  });
  const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
  sunMesh.position.set(100, 150, 50);
  scene.add(sunMesh);

  const sunGlowGeometry = new THREE.SphereGeometry(15, 32, 32);
  const sunGlowMaterial = new THREE.MeshBasicMaterial({
    color: 0xFFA500,
    transparent: true,
    opacity: 0.4
  });
  const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
  sunGlow.position.copy(sunMesh.position);
  scene.add(sunGlow);

  /* ===================== SKY ===================== */
  const sky = new THREE.Mesh(
    new THREE.SphereGeometry(500, 32, 32),
    new THREE.MeshBasicMaterial({ color: 0x87ceeb, side: THREE.BackSide })
  );
  scene.add(sky);

  /* ===================== LIGHTING ===================== */
  const ambient = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambient);

  const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
  sunLight.position.copy(sunMesh.position);
  scene.add(sunLight);

  /* ===================== GROUND ===================== */
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(500, 500),
    new THREE.MeshStandardMaterial({ color: 0x3f7d3c })
  );
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  /* ===================== IMPROVED GRASS CLUMPS ===================== */
  function createGrassClump(x, z) {
    const grassClump = new THREE.Group();
    
    // Create 3-5 grass blades in a clump
    const bladeCount = Math.floor(Math.random() * 3) + 3;
    const grassColor = 0x2e7d32;
    
    for (let i = 0; i < bladeCount; i++) {
      const grass = new THREE.Mesh(
        new THREE.BoxGeometry(0.05, 0.8 + Math.random() * 0.4, 0.05),
        new THREE.MeshStandardMaterial({ color: grassColor })
      );
      
      // Position blades in a small cluster
      const angle = Math.random() * Math.PI * 2;
      const radius = Math.random() * 0.15;
      grass.position.set(
        Math.sin(angle) * radius,
        0.4,
        Math.cos(angle) * radius
      );
      
      // Random rotation for natural look
      grass.rotation.y = Math.random() * Math.PI * 2;
      grass.rotation.x = (Math.random() - 0.5) * 0.3;
      grass.rotation.z = (Math.random() - 0.5) * 0.2;
      
      grassClump.add(grass);
    }
    
    grassClump.position.set(x, 0, z);
    return grassClump;
  }

  // Create grass clumps instead of single blades
  for (let i = 0; i < 200; i++) {
    const grassClump = createGrassClump(
      (Math.random() - 0.5) * 300,
      (Math.random() - 0.5) * 300
    );
    scene.add(grassClump);
  }

  /* ===================== ROAD ===================== */
  const road = new THREE.Mesh(
    new THREE.BoxGeometry(8, 0.1, 300),
    new THREE.MeshStandardMaterial({ color: 0x5d4037 })
  );
  road.position.y = 0.05;
  scene.add(road);

  /* ===================== CHARACTER WITH FIXED FACE AND ARMS ===================== */
  const player = new THREE.Group();
  scene.add(player);

  // Colors
  const skinColor = 0xF5DEB3;
  const shirtColor = 0x4A90E2;
  const pantsColor = 0x2C3E50;
  const shoeColor = 0x333333;
  const hairColor = 0x8B4513;

  // ===== BODY =====
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(0.8, 1.0, 0.4),
    new THREE.MeshStandardMaterial({ color: shirtColor })
  );
  body.position.y = 1.5;
  player.add(body);

  // ===== HEAD WITH FACE ON FRONT =====
  const head = new THREE.Mesh(
    new THREE.SphereGeometry(0.35, 16, 16),
    new THREE.MeshStandardMaterial({ color: skinColor })
  );
  head.position.y = 2.25;
  player.add(head);

  // Hair (on back of head since face is on front)
  const hair = new THREE.Mesh(
    new THREE.BoxGeometry(0.45, 0.15, 0.45),
    new THREE.MeshStandardMaterial({ color: hairColor })
  );
  hair.position.set(0, 2.45, 0.05); // On back of head
  player.add(hair);

  // ===== FACE ON FRONT =====
  // Eyes (on front of head)
  const leftEye = new THREE.Mesh(
    new THREE.CircleGeometry(0.07, 8),
    new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
  );
  leftEye.position.set(-0.12, 2.3, 0.34); // Front position (positive Z)
  player.add(leftEye);

  const rightEye = leftEye.clone();
  rightEye.position.x = 0.12;
  player.add(rightEye);

  // Pupils
  const leftPupil = new THREE.Mesh(
    new THREE.CircleGeometry(0.03, 6),
    new THREE.MeshBasicMaterial({ color: 0x000000 })
  );
  leftPupil.position.set(-0.12, 2.3, 0.35);
  player.add(leftPupil);

  const rightPupil = leftPupil.clone();
  rightPupil.position.x = 0.12;
  player.add(rightPupil);

  // Smile (on front)
  const smileCurve = new THREE.EllipseCurve(
    0, 0,
    0.08, 0.04,
    0, Math.PI,
    false,
    0
  );
  const smilePoints = smileCurve.getPoints(8);
  const smileGeometry = new THREE.BufferGeometry().setFromPoints(smilePoints);
  const smileMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
  const smile = new THREE.Line(smileGeometry, smileMaterial);
  smile.position.set(0, 2.15, 0.34); // Front position
  player.add(smile);

  // ===== ARMS ON SIDE OF BODY (NOT POINTING OUTWARDS) =====
  // Left Arm - hanging straight down at side
  const leftArm = new THREE.Mesh(
    new THREE.CylinderGeometry(0.08, 0.06, 0.7, 8),
    new THREE.MeshStandardMaterial({ color: shirtColor })
  );
  leftArm.position.set(-0.45, 1.15, 0); // Lower position, at side
  leftArm.rotation.z = Math.PI / 2;
  player.add(leftArm);

  // Right Arm
  const rightArm = leftArm.clone();
  rightArm.position.x = 0.45;
  player.add(rightArm);

  // Hands
  const leftHand = new THREE.Mesh(
    new THREE.SphereGeometry(0.06, 6, 6),
    new THREE.MeshStandardMaterial({ color: skinColor })
  );
  leftHand.position.set(-0.8, 1.15, 0); // At end of arm
  player.add(leftHand);

  const rightHand = leftHand.clone();
  rightHand.position.x = 0.8;
  player.add(rightHand);

  // ===== LEGS =====
  const leftLeg = new THREE.Mesh(
    new THREE.CylinderGeometry(0.13, 0.1, 0.8, 8),
    new THREE.MeshStandardMaterial({ color: pantsColor })
  );
  leftLeg.position.set(-0.2, 0.5, 0);
  player.add(leftLeg);

  const rightLeg = leftLeg.clone();
  rightLeg.position.x = 0.2;
  player.add(rightLeg);

  // ===== FEET =====
  const leftFoot = new THREE.Mesh(
    new THREE.BoxGeometry(0.25, 0.08, 0.35),
    new THREE.MeshStandardMaterial({ color: shoeColor })
  );
  leftFoot.position.set(-0.2, 0.06, 0.08);
  player.add(leftFoot);

  const rightFoot = leftFoot.clone();
  rightFoot.position.x = 0.2;
  player.add(rightFoot);

  player.position.z = 20;

  // Character rotation variables
  let characterRotation = 0;
  const ROTATION_SPEED = 0.08;

  /* ===================== TREASURE HUNT COINS ===================== */
  let collectedCoins = 0;
  const totalCoins = 5;
  const coins = [];
  const coinSound = new Audio("https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3");
  coinSound.volume = 0.5;

  function createCoin(x, z) {
    const coinGroup = new THREE.Group();
    
    const coinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 16);
    const coinMaterial = new THREE.MeshStandardMaterial({ 
      color: 0xFFD700,
      metalness: 1.0,
      roughness: 0.3
    });
    const coin = new THREE.Mesh(coinGeometry, coinMaterial);
    coinGroup.add(coin);
    
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 64;
    canvas.height = 64;
    ctx.fillStyle = 'black';
    ctx.font = 'bold 40px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('$', 32, 32);
    
    const texture = new THREE.CanvasTexture(canvas);
    const dollarMaterial = new THREE.MeshBasicMaterial({ 
      map: texture,
      transparent: true,
      side: THREE.DoubleSide
    });
    const dollarSign = new THREE.Mesh(
      new THREE.PlaneGeometry(0.6, 0.6),
      dollarMaterial
    );
    dollarSign.rotation.x = Math.PI / 2;
    dollarSign.position.y = 0.06;
    coinGroup.add(dollarSign);
    
    coinGroup.position.set(x, 1, z);
    coinGroup.userData = { collected: false };
    coinGroup.rotation.x = Math.PI / 2;
    
    scene.add(coinGroup);
    coins.push(coinGroup);
    return coinGroup;
  }

  createCoin(-20, -20);
  createCoin(20, -60);
  createCoin(-25, -100);
  createCoin(25, -140);
  createCoin(0, -180);

  function checkCoinCollision() {
    const playerPos = player.position;
    
    coins.forEach((coin, index) => {
      if (!coin.userData.collected) {
        const distance = playerPos.distanceTo(coin.position);
        
        if (distance < 2) {
          coin.userData.collected = true;
          collectedCoins++;
          
          document.getElementById('coinCounter').textContent = `ðŸ’° Coins: ${collectedCoins}/${totalCoins}`;
          
          coinSound.currentTime = 0;
          coinSound.play();
          
          const startTime = Date.now();
          const originalY = coin.position.y;
          
          function animateCollection() {
            const elapsed = Date.now() - startTime;
            if (elapsed < 1000) {
              const progress = elapsed / 1000;
              coin.position.y = originalY + progress * 5;
              coin.scale.setScalar(1 - progress);
              coin.children[0].material.opacity = 1 - progress;
              coin.children[1].material.opacity = 1 - progress;
              requestAnimationFrame(animateCollection);
            } else {
              scene.remove(coin);
            }
          }
          animateCollection();
          
          if (collectedCoins === totalCoins) {
            setTimeout(() => {
              alert('ðŸŽ‰ Congratulations! You collected all the coins!');
            }, 1200);
          }
        }
      }
    });
  }

  /* ===================== 3RD PERSON CAMERA ===================== */
  let cameraYaw = 0;
  let cameraPitch = 0.5;
  let cameraDistance = 6;
  
  const MIN_PITCH = 0.1;
  const MAX_PITCH = Math.PI / 2 - 0.1;
  const MIN_DISTANCE = 3;
  const MAX_DISTANCE = 12;

  let pointerActive = false;

  /* ===================== CONTROLS ===================== */
  document.body.addEventListener("click", () => {
    renderer.domElement.requestPointerLock();
  });

  document.addEventListener("pointerlockchange", () => {
    pointerActive = document.pointerLockElement === renderer.domElement;
    document.body.style.cursor = pointerActive ? "none" : "default";
  });

  document.addEventListener("mousemove", e => {
    if (!pointerActive) return;
    
    cameraYaw -= e.movementX * 0.002;
    cameraPitch += e.movementY * 0.002;
    cameraPitch = Math.max(MIN_PITCH, Math.min(MAX_PITCH, cameraPitch));
  });

  document.addEventListener("wheel", e => {
    cameraDistance += e.deltaY * 0.01;
    cameraDistance = Math.max(MIN_DISTANCE, Math.min(MAX_DISTANCE, cameraDistance));
  });

  /* ===================== MOVEMENT & CHARACTER ROTATION ===================== */
  const keys = {};
  addEventListener("keydown", e => keys[e.code] = true);
  addEventListener("keyup", e => keys[e.code] = false);

  let walkTime = 0;
  let idleTime = 0;

  /* ===================== IMPROVED HOUSE FUNCTION ===================== */
  function createHouse(x, z, color, label = "", url = "", hasSecondFloor = false, hasTwoWindows = false) {
    const house = new THREE.Group();

    // House body height (taller for 2nd floor)
    const bodyHeight = hasSecondFloor ? 6 : 4;
    
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(6, bodyHeight, 6),
      new THREE.MeshStandardMaterial({ color })
    );
    body.position.y = bodyHeight / 2;
    house.add(body);

    // Roof position depends on body height
    const roof = new THREE.Mesh(
      new THREE.ConeGeometry(5, 3, 4),
      new THREE.MeshStandardMaterial({ color: 0x5a3825 })
    );
    roof.position.y = bodyHeight + 1.5;
    roof.rotation.y = Math.PI / 4;
    house.add(roof);

    // Door
    const door = new THREE.Mesh(
      new THREE.BoxGeometry(1.5, 2.5, 0.2),
      new THREE.MeshStandardMaterial({ color: 0xffffff })
    );
    door.position.set(0, 1.25, 3.1);
    door.userData = { url: url, label: label };
    house.add(door);

    // Windows
    const windowMaterial = new THREE.MeshStandardMaterial({ color: 0x88ccee });
    
    // Left window (always present)
    const leftWindow = new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 0.2),
      windowMaterial
    );
    leftWindow.position.set(-2, 2.5, 3.1);
    house.add(leftWindow);

    // Right window (if hasTwoWindows is true)
    if (hasTwoWindows) {
      const rightWindow = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1, 0.2),
        windowMaterial
      );
      rightWindow.position.set(2, 2.5, 3.1);
      house.add(rightWindow);
    }

    // Second floor window (if hasSecondFloor is true)
    if (hasSecondFloor) {
      const secondFloorWindow = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1, 0.2),
        windowMaterial
      );
      secondFloorWindow.position.set(0, 5, 3.1); // Higher position for 2nd floor
      house.add(secondFloorWindow);
    }

    // Label
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    context.font = 'bold 36px Arial';
    const textWidth = context.measureText(label).width;
    
    canvas.width = textWidth + 40;
    canvas.height = 50;
    
    context.fillStyle = 'rgba(0, 0, 0, 0.8)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    context.strokeStyle = 'white';
    context.lineWidth = 3;
    context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
    
    context.fillStyle = 'white';
    context.font = 'bold 36px Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(label.toUpperCase(), canvas.width / 2, canvas.height / 2);
    
    const texture = new THREE.CanvasTexture(canvas);
    const spriteMaterial = new THREE.SpriteMaterial({ 
      map: texture,
      transparent: true
    });
    const labelSprite = new THREE.Sprite(spriteMaterial);
    labelSprite.scale.set(8, 8 * (canvas.height / canvas.width), 1);
    labelSprite.position.set(0, bodyHeight + 3, 0); // Adjust height based on house
    house.add(labelSprite);

    house.position.set(x, 0, z);
    scene.add(house);
    return { house, door };
  }

  /* ===================== CREATE VARIED HOUSES ===================== */
  const houses = [
    // Home: 1 floor, 2 windows
    createHouse(-12, -40, 0xc48a5a, "HOME", "home.html", false, true),
    // About: 2 floors, 1 window
    createHouse(12, -80, 0x8aa5c4, "ABOUT", "about.html", true, false),
    // Photos: 2 floors, 2 windows
    createHouse(-12, -120, 0x9ac48a, "PHOTOS", "photos.html", true, true),
    // Contact: 1 floor, 1 window
    createHouse(12, -160, 0xc4a88a, "CONTACT", "contact.html", false, false)
  ];

  const doors = houses.map(h => h.door);

  /* ===================== CLICK INTERACTION ===================== */
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  document.addEventListener("click", (e) => {
    if (!pointerActive) return;
    
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(doors);
    
    if (intersects.length > 0) {
      const door = intersects[0].object;
      const originalColor = door.material.color.getHex();
      
      door.material.color.setHex(0x00FF00);
      
      setTimeout(() => {
        door.material.color.setHex(originalColor);
        
        if (door.userData.url) {
          alert(`Going to: ${door.userData.label}`);
        }
      }, 300);
    }
  });

  /* ===================== ANIMATION LOOP ===================== */
  function updateCameraPosition() {
    const cameraOffset = new THREE.Vector3(
      Math.sin(cameraYaw) * Math.cos(cameraPitch) * cameraDistance,
      Math.sin(cameraPitch) * cameraDistance,
      Math.cos(cameraYaw) * Math.cos(cameraPitch) * cameraDistance
    );
    
    camera.position.copy(player.position).add(cameraOffset);
    const lookAtTarget = new THREE.Vector3(
      player.position.x,
      player.position.y + 1.2,
      player.position.z
    );
    camera.lookAt(lookAtTarget);
  }

  function animate() {
    requestAnimationFrame(animate);

    // Sun movement
    const time = Date.now() * 0.00005;
    sunMesh.position.x = Math.cos(time) * 80;
    sunMesh.position.y = Math.sin(time) * 30 + 120;
    sunGlow.position.copy(sunMesh.position);
    sunLight.position.copy(sunMesh.position);

    ambient.intensity = 0.5 + Math.sin(time) * 0.3;

    // Animate clouds
    cloudClusters.forEach((cloud, index) => {
      cloud.position.x += cloud.userData.speed;
      
      if (cloud.position.x > 250) {
        cloud.position.x = -250;
        cloud.position.z = (Math.random() - 0.5) * 300;
      }
      
      const floatTime = Date.now() * 0.001;
      const baseY = cloud.userData.originalY;
      cloud.position.y = baseY + Math.sin(floatTime * 0.5 + index) * 1.5;
      cloud.rotation.y += 0.0005;
      
      cloud.children.forEach((child, i) => {
        if (i % 3 === 0) {
          const pulseScale = 1 + Math.sin(floatTime * 0.8 + i) * 0.02;
          child.scale.setScalar(pulseScale);
        }
      });
    });

    // Animate coins
    coins.forEach((coin, index) => {
      if (!coin.userData.collected) {
        coin.rotation.z += 0.05;
        coin.position.y = 1 + Math.sin(Date.now() * 0.002 + index) * 0.3;
      }
    });

    // Character rotation with Q/E keys
    if (keys.KeyQ) {
      characterRotation += ROTATION_SPEED;
    }
    if (keys.KeyE) {
      characterRotation -= ROTATION_SPEED;
    }
    
    // Apply character rotation
    player.rotation.y = characterRotation;

    // Movement (relative to character rotation)
    const forward = new THREE.Vector3(Math.sin(characterRotation), 0, Math.cos(characterRotation));
    const right = new THREE.Vector3(Math.cos(characterRotation), 0, -Math.sin(characterRotation));
    
    let moving = false;

    if (keys.KeyW) {
      player.position.addScaledVector(forward, -0.12);
      moving = true;
    }
    if (keys.KeyS) {
      player.position.addScaledVector(forward, 0.12);
      moving = true;
    }
    if (keys.KeyA) {
      player.position.addScaledVector(right, -0.12);
      moving = true;
    }
    if (keys.KeyD) {
      player.position.addScaledVector(right, 0.12);
      moving = true;
    }

    /* ===================== WALKING ANIMATION ===================== */
    if (moving) {
      walkTime += 0.15;
      
      // Leg swing
      const legSwing = Math.sin(walkTime) * 0.4;
      leftLeg.rotation.x = -legSwing;
      rightLeg.rotation.x = legSwing;
      
      // Foot lift
      leftFoot.position.y = 0.06 + Math.max(0, -Math.sin(walkTime) * 0.08);
      rightFoot.position.y = 0.06 + Math.max(0, Math.sin(walkTime) * 0.08);
      
      // Arm swing (hanging arms swing forward/back)
      const armSwing = Math.sin(walkTime + Math.PI) * 0.4;
      leftArm.rotation.x = armSwing * 0.3;
      rightArm.rotation.x = -armSwing * 0.3;
      
      // Hand follow arms
      leftHand.position.x = -0.8 + Math.sin(armSwing * 0.3) * 0.1;
      leftHand.position.y = 1.15 + Math.cos(armSwing * 0.3) * 0.08;
      
      rightHand.position.x = 0.8 + Math.sin(-armSwing * 0.3) * 0.1;
      rightHand.position.y = 1.15 + Math.cos(-armSwing * 0.3) * 0.08;
      
      // Body bounce
      body.position.y = 1.5 + Math.sin(walkTime * 2) * 0.02;
      head.position.y = 2.25 + Math.sin(walkTime * 2) * 0.02;
      
    } else {
      // IDLE ANIMATIONS
      idleTime += 0.02;
      
      // Gentle breathing motion
      const breath = Math.sin(idleTime * 0.5) * 0.01;
      body.scale.y = 1 + breath;
      
      // Gentle sway
      player.rotation.z = Math.sin(idleTime * 0.3) * 0.02;
      
      // Reset positions
      leftLeg.rotation.x *= 0.9;
      rightLeg.rotation.x *= 0.9;
      leftFoot.position.y = 0.06;
      rightFoot.position.y = 0.06;
      leftArm.rotation.x *= 0.9;
      rightArm.rotation.x *= 0.9;
      body.position.y = 1.5;
      head.position.y = 2.25;
      
      // Hands return to position
      leftHand.position.set(-0.8, 1.15, 0);
      rightHand.position.set(0.8, 1.15, 0);
    }

    checkCoinCollision();
    updateCameraPosition();
    renderer.render(scene, camera);
  }
  
  animate();

  /* ===================== RESIZE HANDLER ===================== */
  addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // Add some trees
  function createSimpleTree(x, z) {
    const tree = new THREE.Group();
    
    const trunk = new THREE.Mesh(
      new THREE.CylinderGeometry(0.3, 0.4, 3, 8),
      new THREE.MeshStandardMaterial({ color: 0x8B4513 })
    );
    trunk.position.y = 1.5;
    tree.add(trunk);
    
    const leaves = new THREE.Mesh(
      new THREE.SphereGeometry(2, 8, 8),
      new THREE.MeshStandardMaterial({ color: 0x228B22 })
    );
    leaves.position.y = 4;
    tree.add(leaves);
    
    tree.position.set(x, 0, z);
    scene.add(tree);
  }

  createSimpleTree(-30, -30);
  createSimpleTree(30, -30);
  createSimpleTree(0, -100);
  createSimpleTree(-25, -150);
  createSimpleTree(25, -150);
</script>
</body>
</html>
