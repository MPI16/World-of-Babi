<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>World</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #000;
}
canvas { display: block; }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* ===================== BASIC SETUP ===================== */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x9fd3ff, 40, 260);

const camera = new THREE.PerspectiveCamera(
  70,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

/* ===================== LIGHTING ===================== */
scene.add(new THREE.AmbientLight(0xffffff, 0.5));

const sun = new THREE.DirectionalLight(0xffffff, 1.3);
sun.position.set(100, 150, 50);
scene.add(sun);

/* ===================== SKY ===================== */
const sky = new THREE.Mesh(
  new THREE.SphereGeometry(600, 32, 32),
  new THREE.MeshBasicMaterial({
    color: 0x9fd3ff,
    side: THREE.BackSide
  })
);
scene.add(sky);

/* ===================== GROUND ===================== */
const grass = new THREE.Mesh(
  new THREE.PlaneGeometry(600, 600),
  new THREE.MeshStandardMaterial({ color: 0x3f7d3a })
);
grass.rotation.x = -Math.PI / 2;
scene.add(grass);

/* ===================== ROAD ===================== */
const road = new THREE.Mesh(
  new THREE.PlaneGeometry(8, 400),
  new THREE.MeshStandardMaterial({ color: 0x5b3a1e })
);
road.rotation.x = -Math.PI / 2;
road.position.y = 0.02;
scene.add(road);

/* ===================== CLOUDS ===================== */
const clouds = [];
for (let i = 0; i < 18; i++) {
  const cloud = new THREE.Group();
  for (let j = 0; j < 4; j++) {
    const puff = new THREE.Mesh(
      new THREE.SphereGeometry(4, 8, 8),
      new THREE.MeshBasicMaterial({ color: 0xffffff })
    );
    puff.position.x = j * 3;
    cloud.add(puff);
  }
  cloud.position.set(
    (Math.random() - 0.5) * 300,
    50 + Math.random() * 25,
    (Math.random() - 0.5) * 300
  );
  clouds.push(cloud);
  scene.add(cloud);
}

/* ===================== HOUSE FUNCTION ===================== */
function createHouse(x, z, color, link) {
  const house = new THREE.Group();

  const body = new THREE.Mesh(
    new THREE.BoxGeometry(8, 5, 8),
    new THREE.MeshStandardMaterial({ color })
  );
  body.position.y = 2.5;
  house.add(body);

  const roof = new THREE.Mesh(
    new THREE.ConeGeometry(6, 4, 4),
    new THREE.MeshStandardMaterial({ color: 0x5a3825 })
  );
  roof.position.y = 6;
  roof.rotation.y = Math.PI / 4;
  house.add(roof);

  const door = new THREE.Mesh(
    new THREE.BoxGeometry(2, 3, 0.2),
    new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xdddddd })
  );
  door.position.set(0, 1.5, 4.1);
  door.userData.link = link;
  house.add(door);

  house.position.set(x, 0, z);
  scene.add(house);

  return door;
}

/* ===================== HOUSES ===================== */
const portals = [];
portals.push(createHouse(-12, -40, 0xc48a5a, "index.html"));
portals.push(createHouse(12, -80, 0x8aa5c4, "about.html"));
portals.push(createHouse(-12, -120, 0x9ac48a, "photos.html"));
portals.push(createHouse(12, -160, 0xc4a88a, "contact.html"));

  /* ===================== HOUSE UPGRADE (ADD-ONLY) ===================== */
scene.traverse(obj => {
  if (obj.type === "Group" && obj.children.length >= 3) {

    // Slightly bigger
    obj.scale.set(1.15, 1.15, 1.15);

    /* ----- FOUNDATION ----- */
    const base = new THREE.Mesh(
      new THREE.BoxGeometry(9.5, 1, 9.5),
      new THREE.MeshStandardMaterial({ color: 0x444444 })
    );
    base.position.y = 0.5;
    obj.add(base);

    /* ----- WINDOWS ----- */
    const windowMat = new THREE.MeshStandardMaterial({
      color: 0x88ccff,
      emissive: 0x224466,
      emissiveIntensity: 0.6
    });

    const windowGeo = new THREE.BoxGeometry(1.2, 1.2, 0.1);

    const w1 = new THREE.Mesh(windowGeo, windowMat);
    w1.position.set(-2.5, 2.8, 4.05);
    obj.add(w1);

    const w2 = w1.clone();
    w2.position.x = 2.5;
    obj.add(w2);

    /* ----- DOOR GLOW ----- */
    obj.children.forEach(c => {
      if (c.geometry && c.geometry.type === "BoxGeometry" && c.position.z > 4) {
        c.material.emissive = new THREE.Color(0xffcc88);
        c.material.emissiveIntensity = 0.4;
      }
    });

    /* ----- GROUND SNAP ----- */
    obj.position.y = 0;
  }
});


/* ===================== PLAYER ===================== */
const player = new THREE.Group();
scene.add(player);

const bodyMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

const torso = new THREE.Mesh(new THREE.BoxGeometry(1, 1.6, 0.6), bodyMat);
torso.position.y = 2.3;
player.add(torso);

const head = new THREE.Mesh(new THREE.SphereGeometry(0.45), bodyMat);
head.position.y = 3.6;
player.add(head);

const armL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.2, 0.3), bodyMat);
armL.position.set(-0.8, 2.3, 0);
player.add(armL);

const armR = armL.clone();
armR.position.x = 0.8;
player.add(armR);

const legL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.3, 0.4), bodyMat);
legL.position.set(-0.3, 0.9, 0);
player.add(legL);

const legR = legL.clone();
legR.position.x = 0.3;
player.add(legR);

player.position.set(0, 0, 30);

/* ===================== CAMERA CONTROL ===================== */
let yaw = 0, pitch = 0;
let locked = false;

renderer.domElement.addEventListener("click", () => {
  renderer.domElement.requestPointerLock();
});

document.addEventListener("pointerlockchange", () => {
  locked = document.pointerLockElement === renderer.domElement;
  document.body.style.cursor = locked ? "none" : "default";
});

document.addEventListener("mousemove", e => {
  if (!locked) return;
  yaw -= e.movementX * 0.002;
  pitch -= e.movementY * 0.002;
  pitch = Math.max(-0.6, Math.min(0.6, pitch));
});

/* ===================== INPUT ===================== */
const keys = {};
addEventListener("keydown", e => keys[e.code] = true);
addEventListener("keyup", e => keys[e.code] = false);

let walk = 0;
const SPEED = 0.18;

/* ===================== MAIN LOOP ===================== */
function animate() {
  requestAnimationFrame(animate);

  clouds.forEach(c => {
    c.position.x += 0.04;
    if (c.position.x > 300) c.position.x = -300;
  });

  const forward = new THREE.Vector3(
    Math.sin(yaw),
    0,
    Math.cos(yaw)
  );

  const right = new THREE.Vector3(
    Math.sin(yaw + Math.PI / 2),
    0,
    Math.cos(yaw + Math.PI / 2)
  );

  let moving = false;

  if (keys.KeyW) { player.position.addScaledVector(forward, SPEED); moving = true; }
  if (keys.KeyS) { player.position.addScaledVector(forward, -SPEED); moving = true; }
  if (keys.KeyA) { player.position.addScaledVector(right, -SPEED); moving = true; }
  if (keys.KeyD) { player.position.addScaledVector(right, SPEED); moving = true; }

  if (moving) {
    walk += 0.15;
    armL.rotation.x = Math.sin(walk) * 0.6;
    armR.rotation.x = -Math.sin(walk) * 0.6;
    legL.rotation.x = -Math.sin(walk) * 0.6;
    legR.rotation.x = Math.sin(walk) * 0.6;
  } else {
    armL.rotation.x *= 0.8;
    armR.rotation.x *= 0.8;
    legL.rotation.x *= 0.8;
    legR.rotation.x *= 0.8;
  }

  const camPos = new THREE.Vector3(
    player.position.x - Math.sin(yaw) * 6,
    player.position.y + 4,
    player.position.z - Math.cos(yaw) * 6
  );
  camera.position.lerp(camPos, 0.12);
  camera.lookAt(player.position.x, player.position.y + 2, player.position.z);

  renderer.render(scene, camera);
}
animate();
  camera.position.lerp(camPos, 0.12);

  /* ===== APPLY LOOK UP / DOWN (PITCH) ===== */
const lookTarget = new THREE.Vector3(
  player.position.x + Math.sin(yaw) * 10,
  player.position.y + 2 + Math.sin(pitch) * 8,
  player.position.z + Math.cos(yaw) * 10
);

camera.lookAt(lookTarget);



/* ===================== RESIZE ===================== */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>

